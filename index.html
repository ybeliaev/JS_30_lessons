<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JS tutorial</title>

  <link
    href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,300;0,400;0,500;0,600;0,800;1,300;1,400&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="./css/main.css" />
</head>

<body>
  <div class="container">
    <header>
      <h1>Уроки по JavaScript</h1>
      <span>Справка, работа с DOM..</span>
    </header>
    <section class="container-item">
      <h2>Прототип.</h2>
      <p>В JavaScript объекты имеют специальное скрытое свойство <code>[[Prototype]]</code> (так оно названо в
        спецификации), которое
        либо равно <code>null</code>, либо ссылается на другой объект. Объект, на который ссылается
        <code>[[Prototype]]</code>, называется "прототипом".</p>

      <div class="alert">
        <p><code>__proto__</code> — не то же самое, что <code>[[Prototype]]</code>. Это геттер/сеттер для него.</p>
      </div>
      <p>
        <pre>
        <code>          
            let animal = {
              eats: true,
              walk() {
                console.log("Animal walk");
              }
            };
            
            let rabbit = {
              jumps: true, 
            };
            rabbit.__proto__ = animal;
            
            <span>// walk взят из прототипа</span>
            rabbit.walk(); <span>// Animal walk </span>         
        </code>
      </pre>
      </p>
      <div class="alert">
        <p>Цикл <code>for..in</code> перебирает как свои, так и унаследованные свойства.</p>
        <p>Метод <code>hasOwnProperty()</code> возвращает логическое значение, указывающее, содержит ли объект указанное
          собственное, не унаследованное свойство. Синтаксис: <code>obj.hasOwnProperty(prop)</code></p>
        <p>Метод <code>Object.keys(obj)</code> возвращает массив строковых элементов, соответствующих именам
          перечисляемых свойств, найденных непосредственно в самом объекте. Порядок свойств такой же, как и при ручном
          перечислении свойств в объекте через цикл.</p>
      </div>
      <p>У каждой <strong>функции</strong> по умолчанию уже есть свойство "prototype".
        По умолчанию "prototype" – независимый ( он не равен никакому другому ) объект с единственным свойством
        <code>constructor</code>, которое ссылается на
        функцию-конструктор.</p>
      <p>По умолчанию все функции имеют <code>F.prototype = { constructor: F }</code>, поэтому мы можем получить
        конструктор объекта через свойство <code>constructor</code>.</p>
      <div class="alert">
        <strong>Примечание</strong>: Важно понимать, что существует различие между прототипом объекта (который доступен
        через <code>Object.getPrototypeOf(obj)</code>(возвращает прототип (то есть, внутреннее свойство
        <code>[[Prototype]]</code>) указанного объекта.) или через устаревшее свойство <code>__proto__</code>) и
        свойством
        <code>prototype</code> в функциях-конструкторах. Первое свойство является свойством каждого экземпляра, а второе
        - свойством конструктора.
      </div>
      <p>Наследованные свойства это те, что определены в свойстве <code>prototype</code> (вы можете называть это
        подпространством имен), то есть те, которые начинаются с <code>Object.prototype.</code>, а не те, которые
        начинаются с простого <code>Object</code>. Значение свойства <code>prototype</code> - это объект, который в
        основном представляет собой контейнер для хранения свойств и методов, которые мы хотим наследовать объектами,
        расположенными дальше по цепочке прототипов.</p>
      <pre><code>
          let obj = {};
          console.log(obj.__proto__ === Object.prototype); <span>// true</span>
          console.log(Object.prototype.__proto__);<span> // null</span>
        </code></pre>
      <p>Встроенные объекты, такие как Array, Date, Function и другие, хранят свои методы в прототипах.</p>
      <p>Вообще<code> __proto__</code> есть у всех, даже у примитивов(в таком случае создаётся временный объект..):</p>
      <pre><code>
        let a = 1;
        a.__proto__ === Number.prototype // <span>true</span>
        let b = true;
        b.__proto__ === Boolean.prototype // <span>true</span>
        // <span>Cоответственно понятно равенство:</span>
        const arr-1 = []; 
        const arr-2 = []; 
        arr-1.__proto__ === arr-2.__proto__;
      </code></pre>
      <img src="./imgs/js-1.png" alt="code">

      <p>У каждого объекта есть прототип. Конструктор функция Foo также имеет свой собственный <code>__proto__</code>,
        который является <code>Function.prototype</code>, и который, в свою очередь, также ссылается через свое свойство
        <code>__proto__</code> снова на <code>Object.prototype</code>. </p>
      <p><code>__proto__</code> ссылается на <code>prototype</code> класса, которым был создан.</p>
      <img src="./imgs/js-2.png" alt="prototype">
      <p><strong>Из этого вывод, что <code>prototype</code> есть только у функций ( кроме стрелочных ) и
          класса.</strong></p>
      <h3>Современные способы установки и прямого доступа к прототипу это:</h3>
      <ul>
        <li><code>Object.create(proto[, descriptors])</code> – создаёт пустой объект со свойством
          <code>[[Prototype]]</code>, указанным как <code>proto</code> (может быть <code>null</code>), и необязательными
          дескрипторами свойств.</li>
        <li><code>Object.getPrototypeOf(obj)</code> – возвращает свойство [<code>[Prototype]]</code> объекта
          <code>obj</code> (то же самое, что и геттер <code>__proto__</code>).</li>
        <li><code>Object.setPrototypeOf(obj, proto)</code> – устанавливает свойство <code>[[Prototype]]</code> объекта
          <code>obj</code> как <code>proto</code> (то же самое, что и сеттер <code>__proto__</code>).</li>
      </ul>
      <pre><code>
              let animal = {
          eats: true
        };
        
        <span>// создаём новый объект с прототипом animal</span>
        let rabbit = Object.create(animal);
        
        alert(rabbit.eats); // true
        
        alert(Object.getPrototypeOf(rabbit) === animal); <span>// получаем прототип объекта rabbit</span>
        
        Object.setPrototypeOf(rabbit, {}); <span>// заменяем прототип объекта rabbit на {}</span>
      </code></pre>
    </section>
    <section class="container-item">
      <h2>Классы.</h2>
      <div class="alert">
        <p>
          В объектно-ориентированном программировании класс – это расширяемый шаблон кода для создания объектов, который
          устанавливает в них начальные значения (свойства) и реализацию поведения (методы).<br>
          <p style="font-style:italic">"Пикиведия"</p>
        </p>
      </div>
      <pre><code>
        function Func(name){                              
          this.name = name
        }
        Func.prototype.hello = function(){
          console.log(this.name)
        }
        <span>// то же самое, что и </span>
        class Func{
          constructor(name){
            this.name = name
          }
          hello(){
            console.log(this.name)
          }
        } 
      </code></pre>
      <h3>Отличия класса от чистой функции:</h3>
      <ul>
        <li>В отличие от обычных функций, конструктор класса не может быть вызван без new</li>
        <li>Методы класса являются неперечислимыми. Определение класса устанавливает флаг <code>enumerable</code> в
          <code>false</code> для всех методов в <code>"prototype"</code>.</li>
        <li>Классы всегда используют <code>use strict</code>.</li>
      </ul>
      <h3>Наследование классов</h3>
      <pre><code>
        class Animal {
          constructor(name) {
            this.speed = 0;
            this.name = name;
          }
          run(speed) {
            this.speed = speed;
            alert(`${this.name} бежит со скоростью ${this.speed}.`);
          }
          stop() {
            this.speed = 0;
            alert(`${this.name} стоит.`);
          }
        }
        
        <span>// Наследуем от Animal указывая "extends Animal"</span>
        class Rabbit <strong style="color:red">extends</strong> Animal {
          hide() {
            alert(`${this.name} прячется!`);
          }
        }
        
        let rabbit = new Rabbit("Белый кролик");
        
        rabbit.run(5); <span>// Белый кролик бежит со скоростью 5.</span>
        rabbit.hide(); <span>// Белый кролик прячется!</span>>

        <span>// Rabbit.prototype.__proto__ будет равен Animal.prototype, так что методы были унаследованы.</span>
      </code></pre>
      <div class="alert">
        <p><code>constructor</code> - специальный метод, служащий для создания и инициализации объектов, созданных с
          использованием <code>class</code>.</p>
      </div>
      <p>Согласно спецификации, если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся
        такой «пустой» конструктор:</p>
      <pre><code>
        class Rabbit extends Animal {          
          constructor(...args) {
            super(...args);
          }
        }
      </code></pre>
      <div class="alert">
        <p>
          Ключевое слово <code>super()</code> используется как функция, вызывающая родительский конструктор. Её
          необходимо вызвать до первого обращения к ключевому слову <code>this</code> в теле конструктора.
        </p>
      </div>
      <pre><code>
          <span>Наследование с конструктором:</span>
          class Animal {
            constructor(name) {
              this.speed = 0;
              this.name = name;
            }
            display(){
              console.log(this.name, this.speed);
            } 
          }
          
          class Rabbit extends Animal {          
            constructor(name, earLength) {
              super(name);
              this.earLength = earLength;
            }
            display(){
              super.display();
              console.log("super.display() вызывает реализацию  метода из класса-родителя");
            }
          }          
          
          let rabbit = new Rabbit("Белый кролик", 10);
          alert(rabbit.name); <span>// Белый кролик</span>
          alert(rabbit.earLength); <span>// 10</span>
          console.log(rabbit.display()) // <span>// Белый кролик 0 </span>
          <span>// super.display() вызывает реализацию  метода из класса-родителя</span>
        </code></pre>
      <h3>Статические методы</h3>
      <pre><code>
          class Person{
            constructor(name, age){
                this.name = name;
                this.age = age;
            }
            static nameToUpper(person){
                return person.name.toUpperCase();
            }
            display(){
                console.log(this.name, this.age);
            }
        }
        let tom = new Person("Tom Soyer", 34);
        let personName = Person.nameToUpper(tom);
        console.log(personName); <span>// TOM SOYER</span>
        </code></pre>
      <p>В данном случае определен статический метод <code>nameToUpper()</code>. В качестве параметра он принимает
        объект Person и переводит его имя в верхний регистр. Поскольку статический метод относится классу вцелом, а не к
        объекту, то мы НЕ можем использовать в нем ключевое слово <code>this</code> и через него обращаться к свойствам
        объекта.</p>

    </section>
  </div>

  <script src="./js/main.js"></script>
</body>

</html>